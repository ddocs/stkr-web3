import { BlockchainNetworkId, ContractEvent, SubscribeEvent } from '../types';
import Web3 from 'web3';
import { PromiEvent } from 'web3-core';
import BN from 'bn.js';
import { BaseContract } from './BaseContract';
import { EventBase } from '../EventBase';
import { Contract, EventOptions, PastEventOptions, SendOptions } from 'web3-eth-contract';
interface ICompensate {
    provider: string;
    ankrAmount: BN;
    etherAmount: BN;
}
interface IConfigurationChanged {
    key: string;
    oldValue: BN;
    newValue: BN;
}
interface IDeposit {
    user: string;
    value: BN;
}
interface IFreeze {
    user: string;
    value: BN;
    endsAt: BN;
}
interface IOwnershipTransferred {
    previousOwner: string;
    newOwner: string;
}
interface IProposalFinished {
    proposeID: string;
    result: boolean;
    yes: BN;
    no: BN;
}
interface IPropose {
    proposer: string;
    proposeID: string;
    topic: string;
    content: string;
    span: BN;
}
interface IUnfreeze {
    user: string;
    value: BN;
}
interface IVote {
    holder: string;
    ID: string;
    vote: string;
    votes: BN;
}
interface IWithdraw {
    user: string;
    value: BN;
}
export declare class Governance extends BaseContract {
    readonly events: GovernanceEvents;
    abi: any;
    constructor(web3: Web3, network: BlockchainNetworkId);
    getName(): string;
    _userLocks(param0: string, param1: BN, options?: SendOptions): Promise<BN>;
    allowAddressForFunction(addr: string, topic: string, options?: SendOptions): PromiEvent<Contract>;
    availableAmountForUnlock(user: string, options?: SendOptions): Promise<BN>;
    availableDepositsOf(user: string, options?: SendOptions): Promise<BN>;
    changeOperator(operator: string, options?: SendOptions): PromiEvent<Contract>;
    cleanUserLocks(user: string, options?: SendOptions): PromiEvent<Contract>;
    deposit(options?: SendOptions): PromiEvent<Contract>;
    deposit_1(user: string, options?: SendOptions): PromiEvent<Contract>;
    depositsOf(user: string, options?: SendOptions): Promise<BN>;
    freeze(addr: string, amount: BN, options?: SendOptions): PromiEvent<Contract>;
    frozenDepositsOf(user: string, options?: SendOptions): Promise<BN>;
    getConfig(key: string, addr: string, options?: SendOptions): Promise<BN>;
    getConfig_1(key: string, options?: SendOptions): Promise<BN>;
    getConfig_2(key: string, index: BN, options?: SendOptions): Promise<BN>;
    getConfigAddress(key: string, index: BN, options?: SendOptions): Promise<string>;
    getConfigAddress_1(key: string, options?: SendOptions): Promise<string>;
    getConfigString(key: string, index: BN, options?: SendOptions): Promise<string>;
    getConfigString_1(key: string, options?: SendOptions): Promise<string>;
    go(options?: SendOptions): Promise<string>;
    isPaused(action: string, options?: SendOptions): Promise<boolean>;
    lockedDepositsOf(user: string, options?: SendOptions): Promise<BN>;
    owner(options?: SendOptions): Promise<string>;
    renounceOwnership(options?: SendOptions): PromiEvent<Contract>;
    togglePause(action: string, options?: SendOptions): PromiEvent<Contract>;
    transferOwnership(newOwner: string, options?: SendOptions): PromiEvent<Contract>;
    unfreeze(addr: string, amount: BN, options?: SendOptions): PromiEvent<Contract>;
    withdraw(amount: BN, options?: SendOptions): PromiEvent<Contract>;
    propose(Timespan: BN, Topic: string, Content: string, options?: SendOptions): PromiEvent<Contract>;
    vote(Id: string, Vote: string, options?: SendOptions): PromiEvent<Contract>;
    getVotes(Id: string, Vote: string, options?: SendOptions): Promise<BN>;
    finishProposal(Id: string, options?: SendOptions): PromiEvent<Contract>;
    proposal(Id: string, options?: SendOptions): Promise<{
        result: boolean;
        yes: BN;
        no: BN;
        topic: string;
        content: string;
        status: BN;
        startTime: BN;
        endTime: BN;
    }>;
    changeConfiguration(key: string, value: BN, options?: SendOptions): PromiEvent<Contract>;
    cancelProposal(Id: string, Reason: string, options?: SendOptions): PromiEvent<Contract>;
}
export declare class GovernanceEvents extends EventBase {
    getPastCompensate(options: PastEventOptions | {}): Promise<ContractEvent<ICompensate>[]>;
    getPastConfigurationChanged(options: PastEventOptions | {}): Promise<ContractEvent<IConfigurationChanged>[]>;
    getPastDeposit(options: PastEventOptions | {}): Promise<ContractEvent<IDeposit>[]>;
    getPastFreeze(options: PastEventOptions | {}): Promise<ContractEvent<IFreeze>[]>;
    getPastOwnershipTransferred(options: PastEventOptions | {}): Promise<ContractEvent<IOwnershipTransferred>[]>;
    getPastProposalFinished(options: PastEventOptions | {}): Promise<ContractEvent<IProposalFinished>[]>;
    getPastPropose(options: PastEventOptions | {}): Promise<ContractEvent<IPropose>[]>;
    getPastUnfreeze(options: PastEventOptions | {}): Promise<ContractEvent<IUnfreeze>[]>;
    getPastVote(options: PastEventOptions | {}): Promise<ContractEvent<IVote>[]>;
    getPastWithdraw(options: PastEventOptions | {}): Promise<ContractEvent<IWithdraw>[]>;
    Compensate(options: EventOptions | {}): SubscribeEvent<ICompensate>;
    ConfigurationChanged(options: EventOptions | {}): SubscribeEvent<IConfigurationChanged>;
    Deposit(options: EventOptions | {}): SubscribeEvent<IDeposit>;
    Freeze(options: EventOptions | {}): SubscribeEvent<IFreeze>;
    OwnershipTransferred(options: EventOptions | {}): SubscribeEvent<IOwnershipTransferred>;
    ProposalFinished(options: EventOptions | {}): SubscribeEvent<IProposalFinished>;
    Propose(options: EventOptions | {}): SubscribeEvent<IPropose>;
    Unfreeze(options: EventOptions | {}): SubscribeEvent<IUnfreeze>;
    Vote(options: EventOptions | {}): SubscribeEvent<IVote>;
    Withdraw(options: EventOptions | {}): SubscribeEvent<IWithdraw>;
}
export {};
